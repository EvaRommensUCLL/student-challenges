= Challenge

Maak op je virtueel Linux machine een folder TEST1 aan en ga in deze folder staan om aan de opgaven te beginnen. 
Maak voor iedere opgave een bestand opgaveX.sh aan en zet daar lijn per lijn de verschillende commando's in die je moet uitvoeren om aan de opgave te voldoen. 
Maak een zip met naam r-nummer.zip van deze folder (`cd .. ; zip -r r-nummer.zip TEST1`) en laad enkel deze zip op naar Toledo.

== Opgave 1
Maak een bestand aan genaamd `private`.
Geef het de volgende toegangsrechten:

* Zelf moet je kunnen lezen, schrijven en uitvoeren.
* De groep heeft enkel leesrechten.
* Andere gebruikers kunnen lezen, schrijven noch uitvoeren (m.a.w. geen van de drie).

Maak tevens een bestand aan genaamd `public`.
Geef het de volgende toegangsrechten:

* Je kan zelf lezen en schrijven, maar niet uitvoeren.
* De groep kan lezen en schrijven, maar niet uitvoeren.
* Andere gebruikers kunnen enkel lezen.

== Opgave 2
Onder `data` staan enkele honderden bestanden verspreid over meerdere directories.
We willen dat je een bestand `bigfiles.txt` produceert dat de namen van alle bestanden bevat die minstens 512 bytes groot zijn.
De volgorde waarin deze voorkomen in `bigfiles.txt` kan je zelf kiezen.

=== Voorbeeld
Stel dat de `data` directorystructuur er als volgt uitziet:

```
data
 |
 +- foo
 |   |
 |   +-- a.txt (812 bytes)
 |   |
 |   +-- b.txt (100 bytes)
 |
 +- bar
     |
     +-- c.txt (451 bytes)
     |
     +-- d.txt (999 bytes)
     |
     |-- baz
          |
          +-- e.txt (512 bytes)
```

Het bestand `bigfiles.txt` moet na het uitvoeren van je commando's de volgende regels bevatten:

```
data/foo/a.txt
data/bar/d.txt
data/bar/baz/e.txt
```

== Opgave 3
Het bestand `data.dat` bevat honderden regels met elk 10 getallen op.
Deze getallen worden telkens gescheiden door een spatie.

Genereer een bestand `summary.dat` dat van elke regel enkel het 2de en 5de getal bevat.

=== Voorbeeld
Stel dat `data.dat` de volgende inhoud heeft:

```
4 8 9 7 6 5 4 6 8 7
1 0 8 7 6 5 4 2 3 4
5 7 9 8 4 6 5 2 3 1
8 7 9 6 5 8 9 4 5 0
```

Je commando's moet aanleiding geven tot het bestand `summary.dat` met als inhoud

```
8 6
0 6
7 4
7 5
```

Merk op dat de getallen in de echte `data.dat` niet noodzakelijk uit een enkel cijfer bestaan.

== Opgave 4
Je krijgt drie bestanden genaamd `a.bf`, `b.bf` en `c.bf`.
Voeg de inhoud van deze drie bestanden samen en schrijf dit naar een nieuw bestand genaamd `abc.bf`.
Respecteer de volgorde: `abc.bf` moet eerst de inhoud van `a.bf` bevatten, gevolgd door die van `b.bf`, gevolgd door die van `c.bf`.

=== Voorbeeld
Stel dat de gegeven bestanden de volgende inhoud hebben:

* `a.bf` bevat '\+++'.
* `b.bf` bevat `[][][][]`.
* `c.bf` bevat `<><><>`.

Het bestand `abc.bf` moet dan als inhoud hebben

```
+++[][][][]<><><>
```

== Opgave 5
In de `source` directory staan bestanden.
Gebruik commando's om deze allemaal naar een nieuwe directory `target` te kopiëren.

=== Voorbeeld
Stel dat deze oefening initieel de volgende directorystructuur heeft:

```
copy
  |
  +- source
       |
       +-- a.txt
       +-- b.txt
       +-- c.txt
       +-- d.txt
       +-- e.txt
```

Na het uitvoeren van je commando's moet de nieuwe toestand zijn:

```
copy
  |
  +- source
  |    |
  |    +-- a.txt
  |    +-- b.txt
  |    +-- c.txt
  |    +-- d.txt
  |    +-- e.txt
  |
  +- target
       |
       +-- a.txt
       +-- b.txt
       +-- c.txt
       +-- d.txt
       +-- e.txt
```

== Opgave 6
Je krijgt een bestand `secret.txt`.
Je wil dit encrypteren, zij het op een zeer rudimentaire manier, nl. door een _monoalfabetische substitutie_.
Het idee is gelukkig veel eenvoudiger dan het klinkt: elke letter moet simpelweg vervangen worden door een andere.
Onderstaande tabel geeft hier een overzicht van:

```
abcdefghijklmnopqrstuvwxyz
bgimojstwzcrhuadvlfxqeynpk
```

Deze tabel moet je als volgt interpreteren:

* `a` moet vervangen worden door `b`
* `b` moet vervangen worden door `g`
* `c` moet vervangen worden door `i`
* Enzovoort.

Schrijf het resultaat weg naar een nieuw bestand `encrypted.txt`.

Alle andere tekens (bv. cijfers, interpunctie) moeten behouden blijven.
Je mag ervan uitgaan dat `secret.txt` enkel lowercase letters bevat.
Je hoeft dus niet `A` naar `B` om te zetten, enkel `a` naar `b`.

=== Voorbeeld
Stel dat `secret.txt` onderstaande inhoud heeft:

```
xyz 123.
```

Je commando moet `encrypted.txt` genereren met als inhoud

```
npk 123.
```

== Opgave 7
Stel dat je wenst te weten of een grote download (bv. 1GB) gelukt is, m.a.w. dat elke gedownloade bit klopt.
Een manier om dat na te gaan is het bestand een tweede maal te downloaden en elke bit te vergelijken.
Dit is echter nogal inefficiënt: ter verificatie moet je een extra GB afhalen.
Vervelend is ook dat de verificatiedownload zelf fouten kan bevatten en daardoor er een kans is op vals alarm.

Een beter alternatief zou zijn dat de site waarvan je het bestand hebt gedownload ook het aantal 1-bits in het bestand zou vermelden.
Je zou dan het aantal 1-bits kunnen tellen in je gedownloade bestand en dat vergelijken met wat op de site staat. Om dit aantal voor te stellen heb je slechts 33 bits nodig.
Je ziet dat dit een hele verbetering is: om je bestand te verifiëren heb je slechts 33 bits extra te downloaden.

Er is hier echter ook weer een ernstig probleem. Stel dat er twee fouten optreden: ergens komt een 0-bit verkeerdelijk aan als een 1-bit, en later komt er tevens een 1-bit foutief aan als een 0-bit.
Hierdoor blijft het totaal aantal 1-bits onveranderd.
Een 2de fout kan dus een eerste fout als het ware "ongedaan" maken, waardoor je niet zou opmerken dat de download mislukt is.

Een betere oplossing bestaat eruit om gebruik te maken van *hashfuncties*.
We besparen je de details, maar het komt erop neer dat ook hier, zoals bij het tellen van de 1-bits, een "samenvatting" van het bestand wordt gemaakt.
Deze samenvatting is hooguit enkele tientallen bytes groot, m.a.w. verwaarloosbaar.
Kenmerkend voor hashfuncties is dat deze zeer chaotisch zijn: als er ook maar 1 bit verandert, krijg je een totaal andere samenvatting.
De kans is hierdoor immens klein dat een foute bit een voorgaande kan "neutraliseren" zoals het geval was hierboven.
Hashfuncties zijn dus een veel robuustere manier om fouten te detecteren.

Er zijn een aantal "officiële" hashfuncties die heel meticuleus ontworpen werden en bruikbaar zijn voor cryptografische doeleinden.
Ze hebben prachtige namen zoals MD5, SHA1, SHA2 en SHA3.
Voor deze opdracht zullen we SHA1 gebruiken.

Je krijgt een bestand `original.txt`.
Bereken er de SHA1 hash van in hexadecimale vorm.
Schrijf dit weg naar `hash.txt`.

## Voorbeeld

Stel dat `original.txt` het woord `abc` bevat.
Je shellscript moet dan een bestand `hash.txt` genereren met als inhoud

```
a9993e364706816aba3e25717850c26c9cd0d89d
```

Merk op dat je inderdaad een heel andere hash krijgt indien je de invoer wat verandert: `abd` geeft als hash `cb4cc28df0fdbe0ecf9d9662e294b118092a5735`, wat geen enkele gelijkenis vertoont met de andere hash.


== Opgave 8
Onder `data` staan tal van bestanden verspreid over meerdere directories.
Zoek naar alle JavaScript bestanden (bestanden met extensie `.js`) en schrijf de namen ervan naar een bestand genaamd `js-files.txt`.
De volgorde waarin deze namen voorkomen maakt niks uit.

## Voorbeeld

```
data
 |
 +- foo
 |   |
 |   +-- a.js
 |   |
 |   +-- b.py
 |
 +- bar
     |
     +-- c.rb
     |
     +-- d.js
     |
     +-- baz
          |
          +-- qux
               |
               +-- e.js
```

Je script moet het bestand `js-files.txt` aanmaken met als inhoud

```
data/foo/a.js
data/bar/d.js
data/bar/baz/qux/e.js
```

== Opgave 9

Je krijgt een bestand `input.txt`.
Je moet deze regel per regel kopiëren naar een bestand `output.txt` waarbij je alle regels weglaat die beginnen met een `\#`.
Merk op dat een regel die `#` bevat, maar niet aan het begin, mee gekopieerd moet worden.
M.a.w. `# abc` moet weggefilterd worden, maar niet `x # abc`.

## Voorbeeld

Stel dat `input.txt` onderstaande inhoud heeft:

```
abc
xyz
# tralala
12345
xyz # once more
# ...
```

Na uitvoering van je script moet er een bestand `output.txt` bestaan met als inhoud

```
abc
xyz
12345
xyz # once more
```
== Opgave 10
Je krijgt een reeks bestanden genaamd `fileNNN` met `NNN` een getal gaande `001` tot `999`.
Hernoem elk van deze bestanden naar `fileNNNb`, m.a.w. voeg een extra `b` toe aan elke bestandsnaam.

=== Voorbeeld
Stel dat je begint met bestanden
```
file001
file002
file003
```
Na je script zouden de bestanden
```
file001b
file002b
file003b
```
moeten heten.

== Opgave 11
Je krijgt een reeks bestanden genaamd `a.txt`, `b.txt`, ... , `z.txt`.
Bepaal van elk de grootte in bytes en schrijf de resultaten naar `sizes.dat`.
Elke regel van `sizes.dat` moet bestaan uit

* De grootte van het bestand in bytes
* Een of meer whitespaces (spaties, tabs, ...)
* De bestandsnaam

De volgorde waarin de bestanden opgelijst worden kan je vrij kiezen.

=== Voorbeeld

Stel dat er slechts drie bestanden zijn, dan zou een mogelijke `sizes.dat` zijn

```
139    a.txt
7867   c.txt
468    b.txt
